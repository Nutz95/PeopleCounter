<!doctype html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <title>PeopleCounter v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
</head>

<body>
  <header class="hero">
    <div>
      <p class="eyebrow">PeopleCounter v2</p>
      <h1>GPU-first pipeline</h1>
    </div>
    <div class="hero-note">
      <span>Port {{ port }}</span>
      <span id="conn-status" style="color:var(--muted)">⬤ Connecting…</span>
    </div>
  </header>

  <main class="page-column">

    <!-- ── Video feed + overlay ──────────────────────────────────── -->
    <section class="video-shell">
      <div class="video-wrapper" id="video-wrapper">
        <!-- WebCodecs H.264 path (zero server-side encode) — preferred -->
        <canvas id="video-canvas" style="display:none;width:100%;height:100%;object-fit:contain;"></canvas>
        <!-- MJPEG fallback — shown when WebCodecs is unavailable or stream is not H.264 -->
        <img id="video-feed" src="/api/video" alt="Video feed" />
        <!-- Detection / mask overlay canvas -->
        <canvas id="mask-canvas" class="mask-overlay"></canvas>
        <!-- Segmentation overlay — union of per-person prototype masks (YOLO-seg) -->
        <canvas id="seg-canvas"  class="mask-overlay" style="opacity:0.6;"></canvas>
        <!-- Density heatmap overlay — colourised DM-Count density map -->
        <canvas id="heat-canvas" class="mask-overlay" style="opacity:0.65;"></canvas>

        <!-- Top-left: latency chip -->
        <div class="fps-status" id="latency-chip">— ms</div>
        <!-- Top-right: inference fps / video decode fps -->
        <div class="fps-chip" id="fps-chip">— fps</div>
        <div class="fps-chip" id="display-fps-chip" style="top:2.8rem;">— fps</div>

        <!-- Bottom-left: pipeline stage breakdown -->
        <div class="video-overlay-controls" id="stage-breakdown">
          <div style="background:rgba(5,11,23,0.72);border:1px solid rgba(255,255,255,0.12);border-radius:12px;padding:6px 12px;font-size:0.75rem;line-height:1.7;color:#d1e4ff;">
            <span id="ov-preprocess">preprocess — ms</span><br>
            <span id="ov-global">global — ms</span><br>
            <span id="ov-tiles">tiles — ms</span>
          </div>
        </div>

        <!-- Bottom-right: fullscreen -->
        <div class="video-actions">
          <button onclick="toggleFullscreen()">⛶ Plein écran</button>
        </div>
      </div>

      <!-- Controls below the video -->
      <div class="control-group">

        <!-- ── Mode selector ──────────────────────────────────────────── -->
        <div class="control-section">
          <div class="control-section-label">Mode d'inférence</div>
          <div class="mode-pills" id="mode-pills">
            <!-- Populated dynamically from /api/config -->
          </div>
          <div class="mode-loading" id="mode-loading" style="display:none">
            <span class="mode-loading-spinner">⟳</span> Chargement du mode…
          </div>
        </div>

        <!-- ── Contextual overlay options (shown per mode) ────────────── -->
        <div class="control-section" id="overlay-section" style="display:none">
          <div class="control-section-label">Overlays</div>
          <div class="overlay-toggles">
            <label class="toggle" id="overlay-bbox" style="display:none">
              <input type="checkbox" id="mask-toggle" checked>
              Bounding boxes
            </label>
            <label class="toggle" id="overlay-seg" style="display:none">
              <input type="checkbox" id="seg-toggle">
              Masques segmentation
            </label>
            <label class="toggle" id="overlay-heatmap" style="display:none">
              <input type="checkbox" id="heatmap-toggle" checked>
              Heatmap densité
            </label>
          </div>
        </div>

        <!-- ── Density peak threshold (shown only in density mode) ────── -->
        <div class="control-section" id="density-threshold-section" style="display:none">
          <div class="control-section-label">Sensibilité détection densité</div>
          <div class="density-slider-row">
            <span class="density-slider-label">Tolérant</span>
            <input type="range" id="density-threshold-slider"
                   min="0" max="0.5" step="0.01" value="0.05"
                   style="flex:1;accent-color:var(--accent)">
            <span class="density-slider-label">Strict</span>
            <span id="density-threshold-value" class="density-threshold-badge">0.05</span>
          </div>
          <div style="font-size:0.68rem;color:rgba(255,255,255,0.4);margin-top:4px">
            Filtre les petits pics (jambes / corps). Augmenter pour réduire les doubles comptages.
          </div>
        </div>

        <!-- ── Preview-only (always visible) ─────────────────────────── -->
        <div class="control-section" id="preview-only-row">
          <label class="toggle">
            <input type="checkbox" id="preview-only-toggle">
            Prévisualisation seule (désactiver tous les overlays)
          </label>
        </div>

      </div>
    </section>

    <!-- ── Metric cards ──────────────────────────────────────────── -->
    <section class="metrics-shell">
      <div class="metrics-grid">

        <article class="metric-card">
          <div class="metric-title">Personnes détectées</div>
          <div class="metric-value" id="count-value" style="color:var(--accent)">—</div>
          <div class="metric-footnote" id="frame-id-label">frame —</div>
        </article>

        <article class="metric-card">
          <div class="metric-title">End-to-end</div>
          <div class="metric-value" id="e2e-value">—</div>
          <div class="metric-footnote">ms latence / <span id="fps-derived">— fps</span> débit réel</div>
        </article>

        <article class="metric-card">
          <div class="metric-title">Preprocess</div>
          <div class="metric-value metric-value--small" id="preprocess-value">—</div>
          <div class="metric-footnote">ms (CPU dispatch, GPU async)</div>
        </article>

        <article class="metric-card">
          <div class="metric-title">Inference tiles</div>
          <div class="metric-value metric-value--small" id="tiles-value">—</div>
          <div class="metric-footnote">ms (chemin critique)</div>
        </article>

        <article class="metric-card">
          <div class="metric-title">Inference global</div>
          <div class="metric-value metric-value--small" id="global-value">—</div>
          <div class="metric-footnote">ms</div>
        </article>

        <article class="metric-card">
          <div class="metric-title">Fusion wait</div>
          <div class="metric-value metric-value--small" id="fusion-value">—</div>
          <div class="metric-footnote">ms (tiles − global)</div>
        </article>

      </div>

      <!-- Latency sparkline graph -->
      <div class="metric-card wide latency-graph-card" style="margin-top:14px">
        <div class="metric-title">Latence end-to-end — 60 dernières frames</div>
        <canvas id="latency-chart" height="170"></canvas>
        <div class="latency-legend">
          <span><span class="legend-dot backend"></span> end_to_end_ms</span>
          <span><span class="legend-dot render" style="background:#f59e0b"></span> inference_tiles_ms</span>
          <span style="color:rgba(255,255,255,0.35)">── 33 ms target (30 fps)</span>
        </div>
      </div>
    </section>

  </main>

  <script>
    // ── Constants ──────────────────────────────────────────────────
    const MAX_HISTORY  = 60;
    const TARGET_MS    = 33.33;  // 30 fps
    const SMOOTH_WIN   = 2000;   // 2-second rolling average window (ms)

    // ── State ──────────────────────────────────────────────────────
    const e2eHist    = [];
    const tilesHist  = [];
    const fpsTs      = [];     // raw timestamps for FPS estimation (from SSE)
    let   showMask      = true;
    let   showSeg       = false;
    let   showHeatmap   = true;
    let   previewOnly   = false;

    // Current inference mode received from /api/config
    let   _activeMode   = 'passthrough';
    let   _modeChanging = false;   // true while waiting for orchestrator to apply

    // Display-FPS tracking (rendered frames per second via WebCodecs/rAF)
    const _dispFpsTs = [];
    const $displayFpsChip = document.getElementById('display-fps-chip');

    // Rolling-average buckets: { t: timestamp_ms, v: value }[]
    const _smooth = {
      e2e:    [],
      tiles:  [],
      global: [],
      preproc: [],
      fusion: [],
    };

    function rollAvg(arr, value) {
      const now = Date.now();
      arr.push({ t: now, v: value });
      while (arr.length && now - arr[0].t > SMOOTH_WIN) arr.shift();
      if (arr.length === 0) return value;
      return arr.reduce((s, x) => s + x.v, 0) / arr.length;
    }

    // ── DOM refs ───────────────────────────────────────────────────
    const $connStatus   = document.getElementById('conn-status');
    const $latencyChip  = document.getElementById('latency-chip');
    const $fpsChip      = document.getElementById('fps-chip');
    const $countValue   = document.getElementById('count-value');
    const $frameLabel   = document.getElementById('frame-id-label');
    const $e2eValue     = document.getElementById('e2e-value');
    const $fpsDerived   = document.getElementById('fps-derived');
    const $preprocValue = document.getElementById('preprocess-value');
    const $tilesValue   = document.getElementById('tiles-value');
    const $globalValue  = document.getElementById('global-value');
    const $fusionValue  = document.getElementById('fusion-value');
    const $ovPreprocess = document.getElementById('ov-preprocess');
    const $ovGlobal     = document.getElementById('ov-global');
    const $ovTiles      = document.getElementById('ov-tiles');
    const maskCanvas    = document.getElementById('mask-canvas');
    const maskCtx       = maskCanvas.getContext('2d');
    const segCanvas     = document.getElementById('seg-canvas');
    const segCtx        = segCanvas.getContext('2d');
    const heatCanvas    = document.getElementById('heat-canvas');
    const heatCtx       = heatCanvas.getContext('2d');
    const latChart      = document.getElementById('latency-chart');
    const latCtx        = latChart.getContext('2d');

    // Source video dimensions received from the server via telemetry.
    let _videoSrcW = 0;
    let _videoSrcH = 0;

    // ── Toggle handlers ────────────────────────────────────────────
    document.getElementById('mask-toggle').addEventListener('change', e => {
      showMask = e.target.checked;
      if (!showMask) maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
    });

    document.getElementById('seg-toggle').addEventListener('change', e => {
      showSeg = e.target.checked;
      if (!showSeg) segCtx.clearRect(0, 0, segCanvas.width, segCanvas.height);
    });

    document.getElementById('heatmap-toggle').addEventListener('change', e => {
      showHeatmap = e.target.checked;
      if (!showHeatmap) heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);
    });

    // ── Density peak threshold slider ──────────────────────────────
    let _densityThreshold = 0.05;  // mirrors server-side DensityDecoder.min_peak_weight

    (function () {
      const slider = document.getElementById('density-threshold-slider');
      const badge  = document.getElementById('density-threshold-value');
      let _debounce = null;

      slider.addEventListener('input', () => {
        const v = parseFloat(slider.value);
        _densityThreshold = v;
        badge.textContent = v.toFixed(2);
        clearTimeout(_debounce);
        _debounce = setTimeout(async () => {
          try {
            await fetch('/api/density/threshold', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ threshold: v }),
            });
          } catch(err) {
            console.warn('density threshold update failed:', err);
          }
        }, 150);  // 150 ms debounce — avoids flooding during drag
      });
    })();

    document.getElementById('preview-only-toggle').addEventListener('change', e => {
      previewOnly = e.target.checked;
      if (previewOnly) {
        maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
        segCtx.clearRect(0, 0, segCanvas.width, segCanvas.height);
        heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);
      }
    });

    // ── Mode UI ────────────────────────────────────────────────────
    const _modeLabels = {};   // filled from /api/config
    const _modeOverlays = {}; // filled from /api/config

    function _updateOverlaySection(mode) {
      const overlays = _modeOverlays[mode] || [];
      const $section = document.getElementById('overlay-section');
      $section.style.display = overlays.length > 0 ? '' : 'none';
      document.getElementById('overlay-bbox').style.display    = overlays.includes('bbox')    ? '' : 'none';
      document.getElementById('overlay-seg').style.display     = overlays.includes('seg')     ? '' : 'none';
      document.getElementById('overlay-heatmap').style.display = overlays.includes('heatmap') ? '' : 'none';

      // Density threshold section: only visible in density mode.
      const hasDensity = overlays.includes('heatmap');
      document.getElementById('density-threshold-section').style.display = hasDensity ? '' : 'none';

      // Enable overlays by default when entering a mode that supports them;
      // disable them when leaving (keeps state clean on mode switch).
      showMask = overlays.includes('bbox');
      document.getElementById('mask-toggle').checked = showMask;

      showSeg = overlays.includes('seg');
      document.getElementById('seg-toggle').checked = showSeg;
      if (!showSeg) segCtx.clearRect(0, 0, segCanvas.width, segCanvas.height);

      showHeatmap = overlays.includes('heatmap');
      document.getElementById('heatmap-toggle').checked = showHeatmap;
      if (!showHeatmap) heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);

      // "Prévisualisation seule" master toggle — only meaningful when there are overlays
      const $previewRow = document.getElementById('preview-only-row');
      if ($previewRow) $previewRow.style.display = overlays.length > 0 ? '' : 'none';
    }

    function _renderModePills(availableModes, activeMode) {
      const $pills = document.getElementById('mode-pills');
      $pills.innerHTML = '';
      for (const m of availableModes) {
        const btn = document.createElement('button');
        btn.className = 'mode-pill' + (m === activeMode ? ' mode-pill--active' : '');
        btn.dataset.mode = m;
        btn.textContent = _modeLabels[m] || m;
        btn.addEventListener('click', () => _requestModeChange(m));
        $pills.appendChild(btn);
      }
    }

    function _setActivePill(mode) {
      document.querySelectorAll('.mode-pill').forEach(btn => {
        btn.classList.toggle('mode-pill--active', btn.dataset.mode === mode);
      });
    }

    async function _requestModeChange(newMode) {
      if (newMode === _activeMode || _modeChanging) return;
      _modeChanging = true;
      document.getElementById('mode-loading').style.display = '';
      document.querySelectorAll('.mode-pill').forEach(b => b.disabled = true);

      try {
        const res = await fetch('/api/mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mode: newMode }),
        });
        const json = await res.json();
        if (json.ok) {
          // Optimistic UI update
          _activeMode = newMode;
          _setActivePill(newMode);
          _updateOverlaySection(newMode);
          // Clear metric display while new models warm up
          $countValue.textContent = '—';
          $e2eValue.textContent   = '—';
          $tilesValue.textContent = '—';
          $globalValue.textContent= '—';
        }
      } catch (err) {
        console.warn('Mode change failed:', err);
      } finally {
        // Keep loading indicator for 1.5 s to cover engine load time
        setTimeout(() => {
          _modeChanging = false;
          document.getElementById('mode-loading').style.display = 'none';
          document.querySelectorAll('.mode-pill').forEach(b => b.disabled = false);
        }, 1500);
      }
    }

    // Load config from server and initialise the UI
    async function _loadConfig() {
      try {
        const res  = await fetch('/api/config');
        const cfg  = await res.json();
        Object.assign(_modeLabels,   cfg.mode_labels   || {});
        Object.assign(_modeOverlays, cfg.mode_overlays || {});
        _activeMode = cfg.mode || 'passthrough';
        _renderModePills(cfg.available_modes || ['passthrough'], _activeMode);
        _updateOverlaySection(_activeMode);
        // Sync density threshold slider to server-side value.
        if (typeof cfg.density_threshold === 'number') {
          const v = cfg.density_threshold;
          _densityThreshold = v;
          document.getElementById('density-threshold-slider').value = v;
          document.getElementById('density-threshold-value').textContent = v.toFixed(2);
        }
      } catch(e) {
        // Server not up yet or no config endpoint — stay in passthrough
        _renderModePills(['passthrough'], 'passthrough');
      }
    }
    _loadConfig();

    // ── SSE connection ─────────────────────────────────────────────
    const sse = new EventSource('/api/stream');

    sse.addEventListener('message', e => {
      let msg;
      try { msg = JSON.parse(e.data); } catch { return; }
      if (!msg || !msg.frame_id) return;

      // ── Passthrough heartbeat ─────────────────────────────────────
      // No inference payload — just count FPS from the frame flow.
      if (msg.passthrough) {
        const now = Date.now();
        fpsTs.push(now);
        while (fpsTs.length && now - fpsTs[0] > 2000) fpsTs.shift();
        const fps = fpsTs.length > 1
          ? Math.round((fpsTs.length - 1) / ((now - fpsTs[0]) / 1000))
          : 0;
        $connStatus.textContent = '⬤ Live';
        $connStatus.style.color = 'var(--accent)';
        $fpsChip.textContent    = fps ? `${fps} fps` : '— fps';
        $latencyChip.textContent = `frame ${msg.frame_id}`;
        $latencyChip.style.background = 'rgba(42,223,165,0.12)';
        $frameLabel.textContent = `frame ${msg.frame_id}`;
        // In passthrough, metrics are N/A
        $e2eValue.textContent     = '—';
        $fpsDerived.textContent   = fps ? `${fps} fps` : '— fps';
        $countValue.textContent   = '—';
        $preprocValue.textContent = '—';
        $tilesValue.textContent   = '—';
        $globalValue.textContent  = '—';
        $fusionValue.textContent  = '—';
        return;
      }

      const payload = Array.isArray(msg.payload) ? msg.payload : [];
      const tel     = (payload.find(p => p && p.telemetry) || {}).telemetry || {};

      // Update cached video source dimensions whenever the server reports them.
      if (tel.frame_width  > 0) _videoSrcW = tel.frame_width;
      if (tel.frame_height > 0) _videoSrcH = tel.frame_height;

      // ── Person count ─────────────────────────────────────────────
      let count = 0;
      for (const p of payload) {
        if (!p) continue;
        if (Array.isArray(p.detections)) count = Math.max(count, p.detections.length);
        if (typeof p.count === 'number')         count = Math.max(count, p.count);
        if (typeof p.density_count === 'number') count = Math.max(count, Math.round(p.density_count));
      }

      // ── Metrics from telemetry snapshot ──────────────────────────
      const e2e      = +(tel.end_to_end_ms                      ?? 0);
      const preproc  = +(tel.preprocess_ms                      ?? 0);
      const tiles    = +(tel.inference_model_yolo_tiles_ms      ?? 0);
      const global_  = +(tel.inference_model_yolo_global_ms     ?? 0);
      const fusion   = +(tel.fusion_wait_ms                     ?? 0);
      const decodeSum = +(tel.decode_model_sum_ms               ?? 0);

      const hasTelemetry = e2e > 0 || tiles > 0 || global_ > 0;

      // ── FPS ──────────────────────────────────────────────────────
      const now = Date.now();
      if (hasTelemetry) {
        fpsTs.push(now);
        while (fpsTs.length && now - fpsTs[0] > 2000) fpsTs.shift();
      }
      const fps = fpsTs.length > 1
        ? Math.round((fpsTs.length - 1) / ((now - fpsTs[0]) / 1000))
        : 0;

      // ── Compute rolling averages ──────────────────────────────────
      const avgE2e    = hasTelemetry ? rollAvg(_smooth.e2e,    e2e)    : (e2eHist.length ? e2eHist[e2eHist.length-1] : 0);
      const avgTiles  = hasTelemetry ? rollAvg(_smooth.tiles,  tiles)  : 0;
      const avgGlobal = hasTelemetry ? rollAvg(_smooth.global, global_): 0;
      const avgPreproc= hasTelemetry ? rollAvg(_smooth.preproc,preproc): 0;
      const avgFusion = hasTelemetry ? rollAvg(_smooth.fusion, fusion) : 0;
      const avgDecode = hasTelemetry ? rollAvg(_smooth.decode ?? (_smooth.decode = []), decodeSum) : 0;

      // ── Update DOM ───────────────────────────────────────────────
      $connStatus.textContent  = '⬤ Live';
      $connStatus.style.color  = 'var(--accent)';

      $countValue.textContent  = count;
      $frameLabel.textContent  = `frame ${msg.frame_id}`;

      $e2eValue.textContent    = avgE2e.toFixed(1);
      $fpsDerived.textContent  = fps ? `${fps} fps` : '— fps';

      $preprocValue.textContent = avgPreproc.toFixed(2);
      $tilesValue.textContent   = avgTiles.toFixed(2);
      $globalValue.textContent  = avgGlobal.toFixed(2);
      $fusionValue.textContent  = avgFusion.toFixed(2);

      // Video overlay chips
      $latencyChip.textContent = `${avgE2e.toFixed(1)} ms`;
      $fpsChip.textContent     = fps ? `${fps} fps` : '— fps';
      $latencyChip.style.background =
        avgE2e <= TARGET_MS
          ? 'rgba(42,223,165,0.18)'
          : avgE2e <= TARGET_MS * 1.2
          ? 'rgba(245,158,11,0.22)'
          : 'rgba(239,68,68,0.22)';

      // Pipeline breakdown overlay
      $ovPreprocess.textContent = `preprocess ${avgPreproc.toFixed(1)} ms`;
      $ovGlobal.textContent     = `global  ${avgGlobal.toFixed(1)} ms`;
      $ovTiles.textContent      = `tiles   ${avgTiles.toFixed(1)} ms  decode ${avgDecode.toFixed(1)} ms`;

      // ── Overlays ─────────────────────────────────────────────────
      // Mask and seg overlays are only drawn when not in preview-only mode.
      if (!previewOnly) {
        if (showMask) drawMask(payload);
        else maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
        if (showSeg)  drawSegMask(payload);
        else segCtx.clearRect(0, 0, segCanvas.width, segCanvas.height);
      }
      // Heatmap clear/draw is independent of previewOnly so toggling the
      // checkbox always takes immediate effect regardless of preview state.
      if (!previewOnly && showHeatmap) drawHeatmap(payload);
      else heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);

      // ── History & chart ──────────────────────────────────────────
      if (hasTelemetry) {
        e2eHist.push(e2e);
        tilesHist.push(tiles);
        if (e2eHist.length  > MAX_HISTORY) e2eHist.shift();
        if (tilesHist.length > MAX_HISTORY) tilesHist.shift();
        drawChart();
      }
    });

    sse.onerror = () => {
      $connStatus.textContent = '⬤ Reconnecting…';
      $connStatus.style.color = '#f59e0b';
    };

    // ── Shared layout helper ──────────────────────────────────────
    // Returns the letterbox display geometry for the current video canvas state.
    // All overlay renderers (bbox, seg, heatmap) use the same layout so overlays
    // are always aligned to the actual video content area.
    // Returns null if the canvas is not yet laid out or source dims are unknown.
    function _computeLayout() {
      const wrapper = maskCanvas.parentElement;
      const W = wrapper.clientWidth;
      const H = wrapper.clientHeight;
      if (W === 0 || H === 0) return null;

      const canvasEl  = document.getElementById('video-canvas');
      const videoEl   = document.getElementById('video-feed');
      const useCanvas = canvasEl.style.display !== 'none';
      const fallbackW = useCanvas ? canvasEl.width  : (videoEl.naturalWidth  || 0);
      const fallbackH = useCanvas ? canvasEl.height : (videoEl.naturalHeight || 0);
      const srcW = _videoSrcW || fallbackW;
      const srcH = _videoSrcH || fallbackH;
      if (srcW <= 0 || srcH <= 0) return null;

      const dispScale = Math.min(W / srcW, H / srcH);
      const dispW = srcW * dispScale;
      const dispH = srcH * dispScale;
      const dispX = (W - dispW) / 2;
      const dispY = (H - dispH) / 2;
      return { W, H, srcW, srcH, dispW, dispH, dispX, dispY };
    }

    // ── Mask overlay: draw detection bboxes ───────────────────────
    function drawMask(payload) {
      const layout = _computeLayout();
      if (!layout) return;
      const { W, H, dispW, dispH, dispX, dispY } = layout;
      maskCanvas.width  = W;
      maskCanvas.height = H;
      maskCtx.clearRect(0, 0, W, H);
      maskCanvas.width  = W;
      maskCanvas.height = H;
      maskCtx.clearRect(0, 0, W, H);
      maskCanvas.width  = W;
      maskCanvas.height = H;
      maskCtx.clearRect(0, 0, W, H);

      for (const p of payload) {
        if (!p || !Array.isArray(p.detections)) continue;
        for (const det of p.detections) {
          if (!det || !Array.isArray(det.bbox) || det.bbox.length < 4) continue;

          // Direct linear mapping — no preprocessing letterbox to undo.
          const [gx1, gy1, gx2, gy2] = det.bbox;
          const bx = dispX + gx1 * dispW;
          const by = dispY + gy1 * dispH;
          const bw = (gx2 - gx1) * dispW;
          const bh = (gy2 - gy1) * dispH;
          if (bw <= 0 || bh <= 0) continue;

          maskCtx.strokeStyle = 'rgba(42,223,165,0.9)';
          maskCtx.fillStyle   = 'rgba(42,223,165,0.12)';
          maskCtx.lineWidth   = 2;
          maskCtx.beginPath();
          maskCtx.roundRect(bx, by, bw, bh, 4);
          maskCtx.fill();
          maskCtx.stroke();

          if (det.label || det.conf != null) {
            const label = [det.label, det.conf != null ? `${(det.conf*100).toFixed(0)}%` : '']
              .filter(Boolean).join(' ');
            maskCtx.fillStyle = 'rgba(5,11,23,0.75)';
            maskCtx.fillRect(bx, by - 18, label.length * 7 + 8, 18);
            maskCtx.fillStyle = '#e5fffa';
            maskCtx.font = '11px monospace';
            maskCtx.fillText(label, bx + 4, by - 4);
          }
        }
      }
    }

    // ── Segmentation mask overlay (YOLO-seg proto masks) ──────────────────────
    // Packed-RGBA trick: write 4 bytes in a single Int32 write via shared ArrayBuffer
    // → ~4× faster than per-channel byte assignment.
    // Canvas RGBA memory order: R G B A → little-endian Int32 = 0xAABBGGRR
    // Teal 50% alpha: R=0x2A G=0xDF B=0xA5 A=0x80 → Int32LE = 0x80A5DF2A
    const _SEG_PIXEL_ON = 0x80A5DF2A;
    const _segOffscreen = document.createElement('canvas');

    function drawSegMask(payload) {
      const layout = _computeLayout();
      if (!layout) return;
      const { W, H, srcW, srcH, dispW, dispH, dispX, dispY } = layout;
      segCanvas.width  = W;
      segCanvas.height = H;
      segCtx.clearRect(0, 0, W, H);

      for (const p of payload) {
        if (!p || !p.seg_mask_raw || !p.seg_mask_w || !p.seg_mask_h) continue;
        const mw  = p.seg_mask_w | 0;
        const mh  = p.seg_mask_h | 0;
        const nPx = mw * mh;

        // Resize offscreen canvas only when dimensions change.
        if (_segOffscreen.width !== mw || _segOffscreen.height !== mh) {
          _segOffscreen.width  = mw;
          _segOffscreen.height = mh;
        }
        const offCtx  = _segOffscreen.getContext('2d');
        const imgData = offCtx.createImageData(mw, mh);

        // Decode base64 → binary string
        const bStr = atob(p.seg_mask_raw);
        if (bStr.length < nPx) continue;

        // Fill RGBA via Int32 packed writes (4× faster than per-channel bytes)
        const int32 = new Int32Array(imgData.data.buffer);
        for (let i = 0; i < nPx; i++) {
          int32[i] = bStr.charCodeAt(i) > 128 ? _SEG_PIXEL_ON : 0;
        }
        offCtx.putImageData(imgData, 0, 0);

        // Crop letterbox padding from 640-space proto → stretch to display area.
        const modelSz = 640;
        const mScale  = Math.min(modelSz / srcW, modelSz / srcH);
        const prepW   = srcW * mScale;
        const prepH   = srcH * mScale;
        const padX    = (modelSz - prepW) / 2;
        const padY    = (modelSz - prepH) / 2;
        const mpadX   = padX  * mw / modelSz;
        const mpadY   = padY  * mh / modelSz;
        const mCntW   = prepW * mw / modelSz;
        const mCntH   = prepH * mh / modelSz;

        segCtx.drawImage(
          _segOffscreen,
          mpadX, mpadY, mCntW, mCntH,   // source region in proto mask
          dispX, dispY, dispW, dispH,    // dest: video display area
        );
      }
    }

    // ── Density heatmap overlay ────────────────────────────────────
    // DensityDecoder now emits a list of hotspot coordinates instead of a
    // full bitmap.  Each hotspot is {x, y, w} where x/y are normalised [0,1]
    // frame coordinates and w ∈ [0,1] is the relative density weight.
    // We render each hotspot as a radial gradient circle scaled by weight —
    // far cheaper than decoding a full ImageData canvas overlay.
    function drawHeatmap(payload) {
      const layout = _computeLayout();
      if (!layout) return;
      const { W, H, dispX, dispY, dispW, dispH } = layout;
      heatCanvas.width  = W;
      heatCanvas.height = H;
      heatCtx.clearRect(0, 0, W, H);

      heatCtx.fillStyle = 'rgba(220, 30, 30, 0.85)';
      for (const p of payload) {
        if (!p || !Array.isArray(p.hotspots) || p.hotspots.length === 0) continue;
        for (const hs of p.hotspots) {
          const cx = dispX + hs.x * dispW;
          const cy = dispY + hs.y * dispH;
          const r  = Math.max(3, Math.round(hs.w * 12));
          heatCtx.beginPath();
          heatCtx.arc(cx, cy, r, 0, 2 * Math.PI);
          heatCtx.fill();
        }
        break;  // only one density payload expected per frame
      }
    }

    // ── Latency chart ─────────────────────────────────────────────
    function drawChart() {
      const W = latChart.offsetWidth || 600;
      const H = 170;
      latChart.width  = W;
      latChart.height = H;
      latCtx.clearRect(0, 0, W, H);

      const N = e2eHist.length;
      if (N < 2) return;

      const allVals = [...e2eHist, ...tilesHist, TARGET_MS];
      const maxVal  = Math.max(...allVals) * 1.15;

      function xOf(i)   { return (i / (MAX_HISTORY - 1)) * W; }
      function yOf(val) { return H - (val / maxVal) * (H - 14); }

      // 33 ms reference line
      latCtx.beginPath();
      latCtx.strokeStyle = 'rgba(255,255,255,0.15)';
      latCtx.setLineDash([5, 5]);
      latCtx.moveTo(0, yOf(TARGET_MS));
      latCtx.lineTo(W, yOf(TARGET_MS));
      latCtx.stroke();
      latCtx.setLineDash([]);
      latCtx.fillStyle = 'rgba(255,255,255,0.28)';
      latCtx.font = '10px sans-serif';
      latCtx.fillText('33 ms', 4, yOf(TARGET_MS) - 3);

      function drawLine(data, color, fill) {
        if (data.length < 2) return;
        latCtx.beginPath();
        latCtx.strokeStyle = color;
        latCtx.lineWidth   = 2;
        // Fill area under curve
        latCtx.moveTo(xOf(0), H);
        for (let i = 0; i < data.length; i++) latCtx.lineTo(xOf(i), yOf(data[i]));
        latCtx.lineTo(xOf(data.length - 1), H);
        latCtx.closePath();
        latCtx.fillStyle = fill;
        latCtx.fill();
        // Stroke
        latCtx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = xOf(i), y = yOf(data[i]);
          if (i === 0) latCtx.moveTo(x, y); else latCtx.lineTo(x, y);
        }
        latCtx.stroke();
      }

      drawLine(tilesHist, 'rgba(245,158,11,0.85)', 'rgba(245,158,11,0.07)');
      drawLine(e2eHist,   'rgba(42,223,165,0.9)',  'rgba(42,223,165,0.08)');
    }

    // ── Fullscreen ────────────────────────────────────────────────
    function toggleFullscreen() {
      const el = document.getElementById('video-wrapper');
      if (!document.fullscreenElement) el.requestFullscreen?.();
      else document.exitFullscreen?.();
    }

    // ── WebCodecs VideoDecoder (zero server-side encode) ──────────
    // Architecture:
    //   PyFFmpegDemuxer → Annex-B H.264 packets → WebSocket binary
    //   → EncodedVideoChunk → VideoDecoder → render queue → rAF → <canvas>
    //
    // Render queue: decoded VideoFrames wait until their PTS time is due.
    // requestAnimationFrame checks PTS against wall-clock elapsed time so the
    // video plays at the correct speed regardless of burst decode timing.
    //
    // Jitter buffer: we allow a 100 ms head-start before the clock starts so
    // the queue is never starved on startup.
    //
    // Backpressure: if decoder.decodeQueueSize exceeds the threshold,
    // non-keyframe packets are dropped so the decoder catches up.
    //
    // Falls back silently to MJPEG if:
    //   • The browser doesn't support WebCodecs  (VideoDecoder undefined)
    //   • The WebSocket can't connect  (network, wrong port, etc.)
    //   • The server sends no init message within 5s  (MJPEG/no H.264 source)
    (function initWebCodecs() {
      if (typeof VideoDecoder === 'undefined') return; // no WebCodecs support

      const WS_URL    = `ws://${window.location.hostname}:{{ ws_port }}`;
      const videoCanvas = document.getElementById('video-canvas');
      const videoFeed   = document.getElementById('video-feed');
      const ctx         = videoCanvas.getContext('2d');

      const RENDER_QUEUE_MAX  = 4;   // max buffered decoded frames
      const DECODE_QUEUE_MAX  = 8;   // drop non-keyframes above this threshold
      const renderQueue = [];

      let decoder        = null;
      let ws             = null;
      let initDone       = false;
      let rafId          = null;
      let _lastInitKey   = null;  // tracks last codec:w:h:desc to skip redundant re-inits
      let _lastVideoFrame = null; // last decoded VideoFrame — re-drawn when queue is empty

      // If no init message arrives in 5 s, the source is not H.264 — keep MJPEG.
      const fallbackTimer = setTimeout(() => {
        if (!initDone) teardown();
      }, 5000);

      function base64ToBuffer(b64) {
        const bin = atob(b64);
        const buf = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
        return buf.buffer;
      }

      function activateCanvas() {
        videoFeed.style.display  = 'none';
        videoCanvas.style.display = 'block';
      }

      function teardown() {
        clearTimeout(fallbackTimer);
        if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null; }
        try { ws && ws.close(); } catch(e) {}
        try { decoder && decoder.close(); } catch(e) {}
        while (renderQueue.length) renderQueue.shift()?.close?.();
        if (_lastVideoFrame) { try { _lastVideoFrame.close(); } catch(e) {} _lastVideoFrame = null; }
        decoder = null; ws = null;
      }

      // ── Render loop ───────────────────────────────────────────────
      // Always display the most-recent decoded frame at the next rAF tick.
      // Older frames are discarded to minimise display latency on a live feed.
      // canvas.width/height are in canvas-buffer pixels (native stream
      // resolution); clientWidth/clientHeight are CSS pixels and must NOT be
      // used as drawImage target dimensions.
      function renderLoop() {
        // Discard all but the latest decoded frame so we never fall behind.
        while (renderQueue.length > 1) {
          renderQueue.shift()?.close();
        }
        if (renderQueue.length > 0) {
          const frame = renderQueue.shift();
          // Release the previous kept frame only when a new one arrives.
          if (_lastVideoFrame) { try { _lastVideoFrame.close(); } catch(e) {} }
          _lastVideoFrame = frame;  // keep reference — do NOT close yet
          // Track display FPS (actual rendered frames per second)
          const now = performance.now();
          _dispFpsTs.push(now);
          while (_dispFpsTs.length && now - _dispFpsTs[0] > 2000) _dispFpsTs.shift();
          const dFps = _dispFpsTs.length > 1
            ? Math.round((_dispFpsTs.length - 1) / ((now - _dispFpsTs[0]) / 1000))
            : 0;
          $displayFpsChip.textContent = dFps ? `${dFps} fps vid` : '— fps vid';
        }
        // Always draw the most-recent frame (re-paints after canvas.width reset or
        // queue-empty gaps so the display never flashes black).
        if (_lastVideoFrame) {
          ctx.drawImage(_lastVideoFrame, 0, 0, videoCanvas.width, videoCanvas.height);
        }
        rafId = requestAnimationFrame(renderLoop);
      }

      function onInitMsg(msg) {
        clearTimeout(fallbackTimer);
        initDone = true;

        const codec    = msg.codec || 'avc1';
        const initKey  = `${codec}:${msg.width || 0}:${msg.height || 0}:${msg.description || ''}`;

        // Skip re-init when nothing changed and the decoder is already running.
        // Prevents canvas.width = x (which clears to black) and decoder reset
        // on stream reconnects where codec/dimensions are identical.
        if (initKey === _lastInitKey && decoder && decoder.state === 'configured') return;
        _lastInitKey = initKey;

        const config = {
          codec,
          optimizeForLatency: true,
          hardwareAcceleration: 'prefer-hardware',
        };
        if (msg.description) config.description = base64ToBuffer(msg.description);
        if (msg.width)  { config.codedWidth  = msg.width;  videoCanvas.width  = msg.width; }
        if (msg.height) { config.codedHeight = msg.height; videoCanvas.height = msg.height; }

        // Close the previous decoder before replacing it (avoids memory leaks).
        if (decoder) {
          try { decoder.close(); } catch (_) {}
          decoder = null;
        }

        decoder = new VideoDecoder({
          output: (frame) => {
            // Keep the render queue bounded: drop the oldest pending frame
            // if the consumer (rAF) hasn't caught up yet.
            if (renderQueue.length >= RENDER_QUEUE_MAX) {
              renderQueue.shift()?.close();
            }
            renderQueue.push(frame);
          },
          error: (e) => {
            console.warn('VideoDecoder error:', e);
            teardown();
            videoFeed.style.display  = '';
            videoCanvas.style.display = 'none';
          },
        });

        VideoDecoder.isConfigSupported(config).then(support => {
          if (!support.supported) {
            teardown();
            return;
          }
          decoder.configure(config);
          activateCanvas();
          // Start the rAF render loop after successfully configuring the decoder.
          if (rafId === null) rafId = requestAnimationFrame(renderLoop);
        }).catch(() => { teardown(); });
      }

      function onBinaryMsg(data) {
        if (!decoder || decoder.state !== 'configured') return;
        const view = new DataView(data);
        const flags      = view.getUint8(0);
        const isKeyframe = (flags & 1) !== 0;

        // Backpressure: drop non-keyframes when the decode queue is backed up.
        if (!isKeyframe && decoder.decodeQueueSize > DECODE_QUEUE_MAX) return;

        // pts_us: u64 LE — read as two u32 to avoid BigInt requirement
        const pts_lo = view.getUint32(1, true);
        const pts_hi = view.getUint32(5, true);
        const pts_us = pts_hi * 4294967296 + pts_lo;   // microseconds

        const payload = data.slice(9);
        try {
          decoder.decode(new EncodedVideoChunk({
            type: isKeyframe ? 'key' : 'delta',
            timestamp: pts_us,
            data: payload,
          }));
        } catch(e) {
          // Usually "decode called before configure" on startup — harmless.
        }
      }

      ws = new WebSocket(WS_URL);
      ws.binaryType = 'arraybuffer';

      ws.onmessage = (ev) => {
        if (typeof ev.data === 'string') {
          let msg;
          try { msg = JSON.parse(ev.data); } catch { return; }
          if (msg && msg.type === 'init') onInitMsg(msg);
        } else {
          onBinaryMsg(ev.data);
        }
      };

      ws.onerror = () => { clearTimeout(fallbackTimer); };
      ws.onclose = () => {
        clearTimeout(fallbackTimer);
        if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null; }
        if (initDone) {
          // Reconnect quickly — the server keeps the stream running.
          setTimeout(initWebCodecs, 500);
        }
      };
    })();
  </script>

</body>
</html>